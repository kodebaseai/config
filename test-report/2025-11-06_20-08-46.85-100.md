# QUALITATIVE TEST ANALYSIS REPORT: Config Package

**Generated:** 2025-11-06 20:08:46
**Analyst:** Senior Test Architect (AI)
**Package:** @kodebase/config
**Test Runner:** Vitest 4.0.7

---

## A) EXECUTIVE SUMMARY

### Overall Score: **85/100** (B+)

**Weighted Breakdown:**
- Behavioral Depth: 22.5/25 (90%)
- Isolation & Determinism: 12/15 (80%)
- Brittleness Risk: 15/15 (100%)
- Risk Alignment: 13.5/15 (90%)
- Signal Density: 9/15 (60%)
- Structure & Readability: 9/10 (90%)
- Execution Health: 3/3 (100%)
- Tooling Hygiene: 1/2 (50%)

### Key Metrics
- **Test Files:** 5
- **Test LOC:** ~1,630 lines
- **Coverage:** Lines 100%, Functions 100%, Branches 100%, Statements 100%
- **Mutation Score:** Not configured (major gap)
- **Mock Ratio:** 0.0 (0 mocks / 140 tests) - **EXCELLENT**
- **Assertion Density:** ~2.5 assertions/test - **GOOD**
- **Focused/Skipped Tests:** 0 files with `.only` or `.skip` - **CLEAN**

### Top 5 Risks

1. **No Mutation Testing** - Perfect coverage (100%) but unknown quality. Assertions may not catch actual bugs.
2. **No Fake Timers** - Uses `Date.now()` in test setup (line 39 of load-config.test.ts), risking non-determinism and race conditions.
3. **Missing Property Tests** - Pure functions (`detectVersion`, `migrateConfig`) lack property-based tests for invariants.
4. **Arrange Bloat** - Integration tests have 20-30 line YAML blocks in `writeFileSync` calls.
5. **Redundant Validation Tests** - Enum validation pattern repeated 5 times (validate-config.test.ts:68-100).

### Top 5 Quick Wins

1. **Add Stryker mutation testing** - Copy-paste config below, run, identify weak assertions.
2. **Inject Fake Timers** - Add `test/setup.ts` with `vi.useFakeTimers()` and `Date.now()` stub.
3. **Add ESLint rules** - Ban focused tests, real I/O patterns, weak assertions (`toBeDefined` without semantic check).
4. **Extract Test Builders** - Replace repeated YAML `writeFileSync` blocks with `ConfigBuilder` fluent API.
5. **Add Property Tests** - Test invariants: "detectVersion always returns supported version", "validateConfig is idempotent".

### 30/60/90 Day Plan

**30 Days (Foundation):**
- ‚úÖ Install Stryker, run baseline mutation report
- ‚úÖ Add fake timers in test setup
- ‚úÖ Add ESLint `vitest/no-focused-tests`, `vitest/no-disabled-tests`
- ‚úÖ Rewrite 10 tests with ConfigBuilder (see Section C)
- ‚úÖ Add 5 property tests for pure functions
- **Exit Criteria:** Mutation score ‚â•70%, no `Date.now()` in tests

**60 Days (Architecture):**
- ‚úÖ Create contract suites for 2 seams: `ConfigLoader`, `ConfigValidator`
- ‚úÖ Add property tests: idempotence, round-trip serialization, version detection monotonicity
- ‚úÖ Build test data builder (`ConfigBuilder`, `CascadeResultBuilder`)
- **Exit Criteria:** Contract tests run against FileSystem & future loaders; 15+ property tests

**90 Days (Culture & Gates):**
- ‚úÖ CI gates: diff coverage ‚â•90%, mutation score ‚â•80%
- ‚úÖ Flake budget policy: <1% failure rate
- ‚úÖ Document test philosophy: "Test invariants, not implementation"
- **Exit Criteria:** Zero arrange bloat; mutation score ‚â•85%; <10 line average test length

---

## B) SCORECARDS (Per Module)

### 1. Configuration Loading ([src/load-config.ts](src/load-config.ts))
**Files:** load-config.test.ts (23 tests, 418 lines)
**Overall Grade:** A- (88/100)

| Dimension | Score | Justification |
|-----------|-------|---------------|
| Behavioral | 5/5 | Tests encode domain rules: default fallback, YAML parsing, validation integration, error propagation with causes |
| Isolation | 4/5 | Excellent temp directory isolation. Loses 1 point for `Date.now()` non-determinism in directory names |
| Brittleness | 5/5 | Zero mocks, tests behavior not implementation. Robust to refactoring. |
| Structure | 5/5 | Clear AAA pattern, excellent describe nesting, descriptive test names |
| Signal | 3/5 | High coverage but unknown mutation score. Some redundant error handling tests |

**Best Example:** [load-config.test.ts:185-224](src/load-config.test.ts#L185-L224) - "YAML parsing errors" section comprehensively tests error cases with cause chains and message details.

**Worst Example:** [load-config.test.ts:323-331](src/load-config.test.ts#L323-L331) - "handles non-Error thrown during YAML parsing" is edge case testing without clear domain invariant.

**Action:** Add property test: "Any valid KodebaseConfig serialized to YAML can be loaded back" (round-trip invariant).

---

### 2. Schema Validation ([src/validate-config.ts](src/validate-config.ts))
**Files:** validate-config.test.ts (24 tests, 415 lines)
**Overall Grade:** A- (86/100)

| Dimension | Score | Justification |
|-----------|-------|---------------|
| Behavioral | 5/5 | Excellent: tests domain rules (enum validation, defaults application, constraint checking) |
| Isolation | 5/5 | Pure function tests, zero I/O, perfect isolation |
| Brittleness | 5/5 | No mocks, tests Zod schemas through public API |
| Structure | 4/5 | Clear organization. Loses 1 point for repetitive enum validation tests |
| Signal | 3/5 | Comprehensive coverage but visible redundancy in enum tests |

**Best Example:** [validate-config.test.ts:289-305](src/validate-config.test.ts#L289-L305) - "validation configuration" tests enforcement flags with semantic assertions.

**Worst Example:** [validate-config.test.ts:68-100](src/validate-config.test.ts#L68-L100) - Five separate tests for enum validation follow identical pattern (consolidate with parameterized tests).

**Action:** Consolidate enum tests into single parameterized test; add property test: "Valid config remains valid after round-trip through validateConfig".

---

### 3. Migration Utilities ([src/migrate-config.ts](src/migrate-config.ts))
**Files:** migrate-config.test.ts (30 tests, 320 lines)
**Overall Grade:** A (90/100)

| Dimension | Score | Justification |
|-----------|-------|---------------|
| Behavioral | 5/5 | **EXEMPLARY:** Tests domain invariants (idempotence, version detection, upgrade paths, downgrade protection) |
| Isolation | 5/5 | Pure logic, zero dependencies, perfect isolation |
| Brittleness | 5/5 | Tests behavior through public API, resilient to implementation changes |
| Structure | 5/5 | Excellent: "Future version migrations" describe block documents design intent |
| Signal | 4/5 | Strong semantic coverage. Loses 1 point for testing implementation (e.g., "indexOf logic works") |

**Best Example:** [migrate-config.test.ts:103-116](src/migrate-config.test.ts#L103-L116) - "is idempotent (running twice produces same result)" encodes critical invariant.

**Worst Example:** [migrate-config.test.ts:212-225](src/migrate-config.test.ts#L212-L225) - "would throw on downgrade if multiple versions existed" tests hypothetical future behavior (premature).

**Action:** Add property test: "For any config, migrateConfig(migrateConfig(c)) === migrateConfig(c)" (idempotence property).

---

### 4. Configuration Presets ([src/presets/](src/presets/))
**Files:** presets.test.ts (38 tests, 299 lines)
**Overall Grade:** A+ (92/100)

| Dimension | Score | Justification |
|-----------|-------|---------------|
| Behavioral | 5/5 | **OUTSTANDING:** Tests comparative properties ("validation strictness increases from solo to enterprise") |
| Isolation | 5/5 | Pure data validation, zero side effects |
| Brittleness | 5/5 | Tests preset characteristics, not internal structure |
| Structure | 5/5 | **EXEMPLARY:** "preset differences" section directly tests business requirements |
| Signal | 5/5 | Perfect: every test encodes a meaningful invariant about preset behavior |

**Best Example:** [presets.test.ts:261-281](src/presets.test.ts#L261-L281) - "validation strictness increases from solo to enterprise" tests cross-cutting business rule.

**Worst Example:** None significant. This module is exemplary.

**Action:** Add property test: "All presets pass validateConfig" (already exists at line 229-236, excellent!).

---

### 5. Integration Tests ([src/integration.test.ts](src/integration.test.ts))
**Files:** integration.test.ts (25 tests, 497 lines)
**Overall Grade:** B+ (84/100)

| Dimension | Score | Justification |
|-----------|-------|---------------|
| Behavioral | 5/5 | Tests end-to-end scenarios with real YAML files and validation |
| Isolation | 4/5 | Good temp directory usage. Loses 1 point for `Date.now()` non-determinism |
| Brittleness | 5/5 | Tests through public API with real file I/O (appropriate for integration tests) |
| Structure | 3/5 | Clear scenarios but 20-30 line YAML blocks create arrange bloat |
| Execution | 4/5 | Fast (32ms), but could be faster with builders |

**Best Example:** [integration.test.ts:395-496](src/integration.test.ts#L395-L496) - "Real-world usage scenarios" section tests actual user workflows.

**Worst Example:** [integration.test.ts:48-114](src/integration.test.ts#L48-L114) - 40+ line YAML string in `writeFileSync` should use builder.

**Action:** Extract `ConfigBuilder.toYAML()` helper; reduce arrange to 3-5 lines per test.

---

## C) TOP 10 CONCRETE REWRITES

### 1. **Non-Deterministic Temp Directory ‚Üí Fake Timers**

**Invariant:** Test isolation requires unique directories, but directory names should be deterministic.

**Current (load-config.test.ts:38-41):**
```typescript
beforeEach(() => {
  testDir = join(tmpdir(), `kodebase-config-test-${Date.now()}`);
  mkdirSync(testDir, { recursive: true });
});
```

**Problem:** `Date.now()` creates non-deterministic paths. Race conditions if tests run in parallel at exact same millisecond.

**Rewritten:**
```typescript
// test/setup.ts
beforeEach(() => {
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-01T00:00:00Z'));
});

// load-config.test.ts
let testCounter = 0;
beforeEach(() => {
  testDir = join(tmpdir(), `kodebase-config-test-${++testCounter}`);
  mkdirSync(testDir, { recursive: true });
});
```

---

### 2. **Redundant Enum Tests ‚Üí Parameterized Test**

**Invariant:** All enum schemas accept valid values and reject invalid ones.

**Current (validate-config.test.ts:68-100):**
```typescript
it("validates post_merge strategies", () => {
  expect(() => postMergeStrategySchema.parse("cascade_pr")).not.toThrow();
  expect(() => postMergeStrategySchema.parse("direct_commit")).not.toThrow();
  expect(() => postMergeStrategySchema.parse("manual")).not.toThrow();
  expect(() => postMergeStrategySchema.parse("invalid")).toThrow(ZodError);
});

it("validates platform types", () => {
  expect(() => platformTypeSchema.parse("github")).not.toThrow();
  // ... 3 more nearly identical tests
});
```

**Problem:** 32 lines testing same pattern for 5 enums. Redundant and brittle.

**Rewritten:**
```typescript
describe("enum validations", () => {
  const enumTestCases = [
    {
      schema: postMergeStrategySchema,
      valid: ["cascade_pr", "direct_commit", "manual"],
      invalid: ["invalid", ""]
    },
    {
      schema: platformTypeSchema,
      valid: ["github", "gitlab", "bitbucket"],
      invalid: ["aws", ""]
    },
    {
      schema: cascadeModeSchema,
      valid: ["immediate", "batched", "manual"],
      invalid: ["async"]
    },
    {
      schema: commitFormatSchema,
      valid: ["conventional", "simple", "custom"],
      invalid: ["free-form"]
    },
  ];

  for (const { schema, valid, invalid } of enumTestCases) {
    describe(schema.description || 'enum', () => {
      it('accepts all valid values', () => {
        for (const v of valid) {
          expect(() => schema.parse(v)).not.toThrow();
        }
      });

      it('rejects all invalid values', () => {
        for (const i of invalid) {
          expect(() => schema.parse(i)).toThrow(ZodError);
        }
      });
    });
  }
});
```

---

### 3. **Arrange Bloat ‚Üí ConfigBuilder**

**Invariant:** Loading config with all sections populates all gitOps fields.

**Current (integration.test.ts:48-114):**
```typescript
it("loads and validates a complete settings.yml file", async () => {
  const configPath = join(testDir, ".kodebase/config");
  mkdirSync(configPath, { recursive: true });

  writeFileSync(
    join(configPath, "settings.yml"),
    `
version: "1.0"
artifactsDir: ".kodebase/artifacts"

gitOps:
  post_merge:
    strategy: cascade_pr
    cascade_pr:
      auto_merge: true
      require_checks: true
      labels:
        - automated
        - cascade
      branch_prefix: "cascade/"
      delete_branch: true

  post_checkout:
    create_draft_pr: true
    # ... 20 more lines ...
`
  );

  const config = await loadConfig(testDir);
  // 15 assertions
});
```

**Problem:** 40+ line YAML string, hard to read and maintain.

**Rewritten:**
```typescript
// test/builders/config-builder.ts
import { stringify } from 'yaml';
import type { KodebaseConfig } from '../../src/types.js';

export class ConfigBuilder {
  private config: Partial<KodebaseConfig> = {
    version: '1.0',
    artifactsDir: '.kodebase/artifacts',
  };

  withCascadePR(opts?: { autoMerge?: boolean; labels?: string[] }): this {
    this.config.gitOps = {
      ...this.config.gitOps,
      post_merge: {
        strategy: 'cascade_pr',
        cascade_pr: {
          auto_merge: opts?.autoMerge ?? true,
          require_checks: true,
          labels: opts?.labels ?? ['automated', 'cascade'],
          branch_prefix: 'cascade/',
          delete_branch: true,
        },
      },
    };
    return this;
  }

  withDraftPR(): this {
    this.config.gitOps = {
      ...this.config.gitOps,
      post_checkout: { create_draft_pr: true, auto_assign: true },
    };
    return this;
  }

  toYAML(): string {
    return stringify(this.config);
  }
}

// Test
it("loads and validates a complete settings.yml file", async () => {
  const configPath = join(testDir, ".kodebase/config");
  mkdirSync(configPath, { recursive: true });

  const yaml = new ConfigBuilder()
    .withCascadePR({ autoMerge: true, labels: ['automated', 'cascade'] })
    .withDraftPR()
    .toYAML();

  writeFileSync(join(configPath, "settings.yml"), yaml);

  const config = await loadConfig(testDir);

  expect(config.gitOps?.post_merge?.strategy).toBe("cascade_pr");
  expect(config.gitOps?.post_merge?.cascade_pr?.auto_merge).toBe(true);
  expect(config.gitOps?.post_checkout?.create_draft_pr).toBe(true);
});
```

---

### 4. **Missing Property Test ‚Üí Idempotence Invariant**

**Invariant:** Validating a valid config multiple times produces identical results.

**Current (none):**
```typescript
// No property test for validateConfig idempotence
```

**Proposed:**
```typescript
import { fc } from 'fast-check';

describe('validateConfig properties', () => {
  it('is idempotent for any valid config', () => {
    fc.assert(
      fc.property(
        fc.record({
          version: fc.constantFrom('1.0'),
          artifactsDir: fc.string(),
          gitOps: fc.option(fc.record({
            post_merge: fc.option(fc.record({
              strategy: fc.constantFrom('cascade_pr', 'direct_commit', 'manual'),
            })),
          })),
        }),
        (input) => {
          const result1 = validateConfig(input);
          const result2 = validateConfig(result1);

          expect(result1).toEqual(result2);
        }
      )
    );
  });
});
```

---

### 5. **Missing Round-Trip Test ‚Üí Serialization Invariant**

**Invariant:** Config ‚Üí YAML ‚Üí Config preserves structure.

**Current (none):**
```typescript
// No round-trip serialization test
```

**Proposed:**
```typescript
import { stringify } from 'yaml';

it('config round-trips through YAML serialization', async () => {
  const original: KodebaseConfig = {
    version: '1.0',
    artifactsDir: 'custom',
    gitOps: {
      post_merge: { strategy: 'direct_commit' },
      platform: { type: 'github' },
      validation: { enforce_schema: true },
    },
  };

  // Serialize to YAML
  const yaml = stringify(original);
  writeFileSync(join(testDir, 'config.yml'), yaml);

  // Load back
  const loaded = await loadConfig(testDir, 'config.yml');

  // Should be structurally identical (Zod may add defaults)
  expect(loaded.version).toBe(original.version);
  expect(loaded.artifactsDir).toBe(original.artifactsDir);
  expect(loaded.gitOps?.post_merge?.strategy).toBe(
    original.gitOps?.post_merge?.strategy
  );
});
```

---

### 6. **Weak Error Assertion ‚Üí Semantic Check**

**Invariant:** Validation errors include field paths to help debugging.

**Current (load-config.test.ts:259-268):**
```typescript
try {
  await loadConfig(testDir);
  expect.fail("Should have thrown");
} catch (error) {
  expect(error).toBeInstanceOf(ConfigLoadError);
  const message = (error as ConfigLoadError).message;
  expect(message).toContain("Configuration validation failed");
  expect(message).toContain("gitOps.post_merge.strategy");
  expect(message).toContain("gitOps.platform.type");
}
```

**Problem:** Verbose error checking pattern repeated 4 times.

**Rewritten:**
```typescript
// test/helpers/assertions.ts
export async function expectConfigLoadError(
  promise: Promise<unknown>,
  expectedPath: string | RegExp
) {
  await expect(promise).rejects.toThrow(ConfigLoadError);
  await expect(promise).rejects.toThrow(
    typeof expectedPath === 'string'
      ? new RegExp(expectedPath.replace('.', '\\.'))
      : expectedPath
  );
}

// Test
it("provides detailed validation error messages", async () => {
  writeFileSync(
    join(configPath, "settings.yml"),
    `
gitOps:
  post_merge:
    strategy: invalid_value
  platform:
    type: unsupported_platform
`
  );

  await expectConfigLoadError(
    loadConfig(testDir),
    /gitOps\.post_merge\.strategy|gitOps\.platform\.type/
  );
});
```

---

### 7. **Missing Monotonicity Test ‚Üí Version Detection Invariant**

**Invariant:** Adding explicit version field should not change detected version.

**Current (none):**
```typescript
// No monotonicity test
```

**Proposed:**
```typescript
it('detectVersion is monotonic with explicit version', () => {
  const configWithoutVersion = {
    artifactsDir: '.kodebase/artifacts'
  };

  const detected = detectVersion(configWithoutVersion);

  // Adding the detected version explicitly should not change detection
  const configWithVersion = {
    ...configWithoutVersion,
    version: detected
  };

  const detected2 = detectVersion(configWithVersion);

  expect(detected).toBe(detected2);
  expect(detected).toBe('1.0');
});
```

---

### 8. **Missing Boundary Test ‚Üí Numeric Constraint Invariant**

**Invariant:** batch_delay_seconds accepts 0 and positive integers, rejects negative.

**Current (validate-config.test.ts:266-286):**
```typescript
it("rejects invalid number ranges", () => {
  expect(() =>
    validateConfig({
      gitOps: { cascades: { batch_delay_seconds: -1 } }
    })
  ).toThrow(ZodError);

  expect(() =>
    validateConfig({
      gitOps: { cascades: { max_parallelism: 0 } }
    })
  ).toThrow(ZodError);
});
```

**Problem:** Tests both constraints together. Should test boundaries explicitly.

**Rewritten:**
```typescript
describe('batch_delay_seconds boundaries', () => {
  it('accepts zero delay (immediate)', () => {
    const config = validateConfig({
      gitOps: { cascades: { batch_delay_seconds: 0 } }
    });

    expect(config.gitOps?.cascades?.batch_delay_seconds).toBe(0);
  });

  it('accepts positive delays', () => {
    const config = validateConfig({
      gitOps: { cascades: { batch_delay_seconds: 300 } }
    });

    expect(config.gitOps?.cascades?.batch_delay_seconds).toBe(300);
  });

  it('rejects negative delays', () => {
    expect(() =>
      validateConfig({
        gitOps: { cascades: { batch_delay_seconds: -1 } }
      })
    ).toThrow(/greater than or equal to 0/);
  });
});
```

---

### 9. **Missing Immutability Test ‚Üí Defensive Copy Invariant**

**Invariant:** Mutating returned config should not affect future getDefaultConfig() calls.

**Current (load-config.test.ts:26-32):**
```typescript
it("returns a new copy each time", () => {
  const config1 = getDefaultConfig();
  const config2 = getDefaultConfig();

  expect(config1).not.toBe(config2);
  expect(config1).toEqual(config2);
});
```

**Problem:** Tests shallow identity but not deep immutability.

**Rewritten:**
```typescript
it("returns immutable defaults (mutations don't leak)", () => {
  const config1 = getDefaultConfig();

  // Mutate the returned config
  config1.artifactsDir = "MUTATED";
  if (config1.gitOps) {
    config1.gitOps.post_merge = undefined;
  }

  // Next call should return pristine defaults
  const config2 = getDefaultConfig();

  expect(config2.artifactsDir).toBe(".kodebase/artifacts");
  expect(config2.gitOps?.post_merge).toBeDefined();
  expect(config2.gitOps?.post_merge?.strategy).toBe("cascade_pr");
});
```

---

### 10. **Missing Property Test ‚Üí Version Detection Always Valid**

**Invariant:** detectVersion always returns a supported version, never undefined or invalid.

**Current (none):**
```typescript
// No property test for detectVersion
```

**Proposed:**
```typescript
import { fc } from 'fast-check';

it('detectVersion always returns a supported version for any input', () => {
  fc.assert(
    fc.property(
      fc.anything(), // Completely arbitrary input
      (input) => {
        const detected = detectVersion(input);

        // Must be one of the supported versions
        expect(SUPPORTED_VERSIONS).toContain(detected);
      }
    )
  );
});
```

---

## D) MECHANICAL FIXES (Copy-Paste Ready)

### 1. ESLint Rules

```javascript
// .eslintrc.cjs (add to overrides for test files)
module.exports = {
  overrides: [
    {
      files: ['**/*.test.{ts,tsx}', '**/*.spec.{ts,tsx}'],
      plugins: ['vitest'],
      rules: {
        // Ban focused/skipped tests
        'vitest/no-focused-tests': 'error',
        'vitest/no-disabled-tests': 'warn',

        // Prevent weak assertions
        'vitest/prefer-to-be': 'warn',
        'vitest/prefer-strict-equal': 'warn',
        'vitest/expect-expect': 'warn',

        // Encourage semantic test names
        'vitest/valid-title': ['error', {
          mustMatch: {
            test: [/^(validates|loads|returns|throws|rejects|accepts|applies|handles)/i]
          }
        }],

        // Ban real I/O patterns in unit tests (warn, not error - config needs real fs)
        'no-restricted-imports': ['warn', {
          patterns: [{
            group: ['child_process'],
            message: 'Avoid shell commands in unit tests. Use integration tests if needed.'
          }]
        }],
      }
    }
  ]
};
```

### 2. Vitest Setup (Fake Timers)

```typescript
// test/setup.ts
import { beforeEach, afterEach, vi } from 'vitest';

beforeEach(() => {
  // Fake timers for deterministic Date.now()
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-01T00:00:00.000Z'));

  // Fake RNG for deterministic Math.random() (if used in code)
  let seed = 0.123456789;
  vi.spyOn(Math, 'random').mockImplementation(() => {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  });
});

afterEach(() => {
  vi.useRealTimers();
  vi.restoreAllMocks();
});
```

```typescript
// vitest.config.ts (update)
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    exclude: ["**/node_modules/**", "**/dist/**"],
    globals: true,
    environment: "node",
    setupFiles: ['./test/setup.ts'], // Add this line
    coverage: {
      provider: "istanbul",
      reporter: ["text", "text-summary", "lcov", "html"],
      enabled: true,
      include: ["src/**/*.ts"],
      exclude: [
        "src/**/*.test.ts",
        "src/**/*.integration.test.ts",
        "test/**/*",
        "**/node_modules/**",
        "**/dist/**",
      ],
      thresholds: {
        lines: 90,
        functions: 90,
        branches: 80,
        statements: 90,
      },
    },
  },
});
```

### 3. Stryker Mutation Testing Config

```javascript
// stryker.conf.cjs
module.exports = {
  packageManager: 'pnpm',
  testRunner: 'vitest',
  vitest: {
    configFile: 'vitest.config.ts',
  },

  // Files to mutate
  mutate: [
    'src/**/*.ts',
    '!src/**/*.test.ts',
    '!src/**/*.spec.ts',
    '!src/index.ts', // Re-exports only
    '!src/types.ts',  // Type definitions
  ],

  // Coverage analysis
  coverageAnalysis: 'perTest',

  // Reporters
  reporters: ['html', 'clear-text', 'progress', 'json'],

  // Thresholds
  thresholds: {
    high: 85,
    low: 75,
    break: 70, // Fail build if <70%
  },

  // Mutation types
  mutator: {
    excludedMutations: [
      'StringLiteral', // Don't mutate error messages or default values
    ],
  },

  // Performance
  concurrency: 4,
  timeoutMS: 60000,

  // Incremental mode for CI
  incremental: true,
  incrementalFile: '.stryker-tmp/incremental.json',
};
```

**Install:** `pnpm add -D @stryker-mutator/core @stryker-mutator/vitest-runner`
**Run:** `npx stryker run`
**CI:** `npx stryker run --incremental` (only test changed files)

### 4. Test Data Builder

```typescript
// test/builders/config-builder.ts
import { stringify } from 'yaml';
import type { KodebaseConfig } from '../../src/types.js';

/**
 * Fluent builder for KodebaseConfig test data.
 *
 * @example
 * const config = new ConfigBuilder()
 *   .withCascadePR({ autoMerge: false })
 *   .withHooks({ enabled: true })
 *   .build();
 */
export class ConfigBuilder {
  private config: Partial<KodebaseConfig> = {
    version: '1.0',
    artifactsDir: '.kodebase/artifacts',
  };

  /**
   * Factory: PR merge workflow preset
   */
  static aPRMerge(): ConfigBuilder {
    return new ConfigBuilder()
      .withCascadePR({ autoMerge: true, requireChecks: true });
  }

  /**
   * Factory: Direct commit workflow preset
   */
  static aDirectCommit(): ConfigBuilder {
    return new ConfigBuilder()
      .withDirectCommit({ pushImmediately: true });
  }

  withVersion(version: string): this {
    this.config.version = version;
    return this;
  }

  withArtifactsDir(dir: string): this {
    this.config.artifactsDir = dir;
    return this;
  }

  withCascadePR(opts?: {
    autoMerge?: boolean;
    requireChecks?: boolean;
    labels?: string[];
  }): this {
    this.config.gitOps = {
      ...this.config.gitOps,
      post_merge: {
        strategy: 'cascade_pr',
        cascade_pr: {
          auto_merge: opts?.autoMerge ?? true,
          require_checks: opts?.requireChecks ?? true,
          labels: opts?.labels ?? ['cascade', 'automated'],
          branch_prefix: 'cascade/',
          delete_branch: true,
        },
      },
    };
    return this;
  }

  withDirectCommit(opts?: {
    pushImmediately?: boolean;
    commitPrefix?: string;
  }): this {
    this.config.gitOps = {
      ...this.config.gitOps,
      post_merge: {
        strategy: 'direct_commit',
        direct_commit: {
          push_immediately: opts?.pushImmediately ?? true,
          commit_prefix: opts?.commitPrefix ?? 'chore(cascade): ',
        },
      },
    };
    return this;
  }

  withHooks(opts?: {
    enabled?: boolean;
    nonBlocking?: boolean;
    validateSchema?: boolean;
  }): this {
    this.config.gitOps = {
      ...this.config.gitOps,
      hooks: {
        enabled: opts?.enabled ?? true,
        non_blocking: opts?.nonBlocking ?? true,
        pre_commit: {
          enabled: true,
          validate_schema: opts?.validateSchema ?? true,
        },
      },
    };
    return this;
  }

  withPlatform(type: 'github' | 'gitlab' | 'bitbucket'): this {
    this.config.gitOps = {
      ...this.config.gitOps,
      platform: {
        type,
        auth_strategy: 'auto',
      },
    };
    return this;
  }

  build(): KodebaseConfig {
    return this.config as KodebaseConfig;
  }

  toYAML(): string {
    return stringify(this.config);
  }
}

// Usage examples:
const prConfig = ConfigBuilder.aPRMerge()
  .withHooks({ enabled: true, nonBlocking: false })
  .build();

const yaml = new ConfigBuilder()
  .withCascadePR({ autoMerge: false })
  .withPlatform('gitlab')
  .toYAML();
```

### 5. Property Test Helpers

```typescript
// test/helpers/arbitraries.ts
import { fc } from 'fast-check';
import type { ConfigVersion } from '../../src/migrate-config.js';
import type { KodebaseConfig } from '../../src/types.js';

/**
 * Arbitrary for supported config versions
 */
export const configVersionArb: fc.Arbitrary<ConfigVersion> =
  fc.constantFrom('1.0' as ConfigVersion);

/**
 * Arbitrary for post-merge strategies
 */
export const postMergeStrategyArb = fc.constantFrom(
  'cascade_pr',
  'direct_commit',
  'manual'
);

/**
 * Arbitrary for platform types
 */
export const platformTypeArb = fc.constantFrom(
  'github',
  'gitlab',
  'bitbucket'
);

/**
 * Arbitrary for valid KodebaseConfig objects
 */
export const validConfigArb: fc.Arbitrary<KodebaseConfig> = fc.record({
  version: fc.option(configVersionArb, { nil: undefined }),
  artifactsDir: fc.option(fc.string(), { nil: undefined }),
  gitOps: fc.option(
    fc.record({
      post_merge: fc.option(
        fc.record({
          strategy: postMergeStrategyArb,
          cascade_pr: fc.option(
            fc.record({
              auto_merge: fc.boolean(),
              require_checks: fc.boolean(),
            })
          ),
        })
      ),
      platform: fc.option(
        fc.record({
          type: platformTypeArb,
        })
      ),
    }),
    { nil: undefined }
  ),
});

/**
 * Arbitrary for arbitrary inputs to detectVersion (tests robustness)
 */
export const arbitraryInputArb = fc.anything();
```

---

## E) CONTRACT TEST TEMPLATES

### Contract 1: ConfigLoader

```typescript
// test/contracts/config-loader.contract.ts
import { describe, it, expect, beforeEach } from 'vitest';
import type { KodebaseConfig } from '../../src/types.js';

/**
 * Reusable contract test for any ConfigLoader implementation.
 * Run this against:
 * - FileSystemLoader (current implementation)
 * - S3ConfigLoader (future: load from S3)
 * - EnvConfigLoader (future: load from env vars)
 */
export function contractConfigLoader(
  name: string,
  makeLoader: () => {
    load: (path: string) => Promise<KodebaseConfig>;
    write: (path: string, config: KodebaseConfig) => Promise<void>;
    exists: (path: string) => Promise<boolean>;
    cleanup: () => Promise<void>;
  }
) {
  describe(`ConfigLoader contract: ${name}`, () => {
    let loader: ReturnType<typeof makeLoader>;

    beforeEach(() => {
      loader = makeLoader();
    });

    afterEach(async () => {
      await loader.cleanup();
    });

    it('returns default config when file does not exist', async () => {
      const config = await loader.load('nonexistent.yml');

      expect(config.version).toBe('1.0');
      expect(config.artifactsDir).toBe('.kodebase/artifacts');
      expect(config.gitOps?.post_merge?.strategy).toBe('cascade_pr');
    });

    it('round-trips: write then load returns equivalent config', async () => {
      const original: KodebaseConfig = {
        version: '1.0',
        artifactsDir: 'custom-dir',
        gitOps: {
          post_merge: { strategy: 'direct_commit' },
          platform: { type: 'gitlab' },
        },
      };

      await loader.write('test.yml', original);
      const loaded = await loader.load('test.yml');

      // Zod may add defaults, so check key fields
      expect(loaded.version).toBe(original.version);
      expect(loaded.artifactsDir).toBe(original.artifactsDir);
      expect(loaded.gitOps?.post_merge?.strategy).toBe(
        original.gitOps?.post_merge?.strategy
      );
      expect(loaded.gitOps?.platform?.type).toBe(
        original.gitOps?.platform?.type
      );
    });

    it('throws ConfigLoadError on invalid YAML syntax', async () => {
      // Write invalid YAML
      const invalidYAML = 'version: "1.0\n  invalid: yaml: [syntax';
      await loader.write('invalid.yml', invalidYAML as any);

      await expect(loader.load('invalid.yml')).rejects.toThrow(/parse.*YAML/i);
    });

    it('throws ConfigLoadError with field paths on validation failure', async () => {
      const invalidConfig = {
        gitOps: {
          post_merge: { strategy: 'invalid_strategy' }
        },
      };
      await loader.write('invalid.yml', invalidConfig as KodebaseConfig);

      try {
        await loader.load('invalid.yml');
        throw new Error('Should have thrown');
      } catch (error: any) {
        expect(error.message).toMatch(/validation failed/i);
        expect(error.message).toMatch(/gitOps\.post_merge\.strategy/);
      }
    });

    it('is idempotent: loading same file twice returns same config', async () => {
      const config: KodebaseConfig = {
        version: '1.0',
        artifactsDir: '.kodebase/artifacts',
      };

      await loader.write('test.yml', config);

      const loaded1 = await loader.load('test.yml');
      const loaded2 = await loader.load('test.yml');

      expect(loaded1).toEqual(loaded2);
    });

    it('exists() returns true only when file exists', async () => {
      expect(await loader.exists('missing.yml')).toBe(false);

      await loader.write('exists.yml', { version: '1.0' } as KodebaseConfig);

      expect(await loader.exists('exists.yml')).toBe(true);
    });
  });
}
```

**Usage:**
```typescript
// test/load-config.contract.test.ts
import { contractConfigLoader } from './contracts/config-loader.contract.js';
import { loadConfig } from '../src/load-config.js';
import { writeFileSync, existsSync, rmSync, mkdirSync } from 'node:fs';
import { join, tmpdir } from 'node:path';
import { stringify } from 'yaml';

contractConfigLoader('FileSystemLoader', () => {
  const testDir = join(tmpdir(), `contract-test-${Date.now()}`);
  mkdirSync(testDir, { recursive: true });

  return {
    load: (path) => loadConfig(testDir, path),
    write: async (path, config) => {
      const fullPath = join(testDir, path);
      writeFileSync(fullPath, stringify(config));
    },
    exists: async (path) => existsSync(join(testDir, path)),
    cleanup: async () => rmSync(testDir, { recursive: true, force: true }),
  };
});
```

---

### Contract 2: ConfigValidator

```typescript
// test/contracts/config-validator.contract.ts
import { describe, it, expect } from 'vitest';
import type { KodebaseConfig } from '../../src/types.js';

/**
 * Reusable contract test for config validators.
 */
export function contractConfigValidator(
  name: string,
  validate: (config: unknown) => KodebaseConfig
) {
  describe(`ConfigValidator contract: ${name}`, () => {
    it('accepts empty object and applies defaults', () => {
      const result = validate({});

      expect(result.version).toBe('1.0');
      expect(result.artifactsDir).toBe('.kodebase/artifacts');
      expect(result.gitOps?.post_merge?.strategy).toBe('cascade_pr');
    });

    it('is idempotent: validate(valid) returns equivalent output', () => {
      const valid: KodebaseConfig = {
        version: '1.0',
        artifactsDir: 'custom',
        gitOps: { post_merge: { strategy: 'manual' } },
      };

      const result1 = validate(valid);
      const result2 = validate(result1);

      // Structural equality (Zod may add defaults)
      expect(result1.version).toBe(result2.version);
      expect(result1.artifactsDir).toBe(result2.artifactsDir);
      expect(result1.gitOps?.post_merge?.strategy).toBe(
        result2.gitOps?.post_merge?.strategy
      );
    });

    it('rejects invalid enum values with meaningful error', () => {
      expect(() =>
        validate({
          gitOps: { post_merge: { strategy: 'invalid_strategy' } },
        })
      ).toThrow(/Invalid enum value/i);
    });

    it('rejects type mismatches with field path in error', () => {
      expect(() =>
        validate({
          gitOps: { hooks: { enabled: 'not_a_boolean' } },
        })
      ).toThrow(/enabled/);
    });

    it('enforces numeric constraints with clear errors', () => {
      expect(() =>
        validate({
          gitOps: { cascades: { batch_delay_seconds: -1 } },
        })
      ).toThrow(/greater than or equal to 0/i);
    });

    it('enforces URL format validation', () => {
      expect(() =>
        validate({
          gitOps: {
            platform: {
              github: { api_url: 'not-a-valid-url' },
            },
          },
        })
      ).toThrow(/url/i);
    });

    it('preserves explicitly set values (does not override with defaults)', () => {
      const config = validate({
        version: '1.0',
        artifactsDir: 'my-custom-dir',
        gitOps: {
          post_merge: {
            strategy: 'direct_commit',
            direct_commit: { push_immediately: false },
          },
        },
      });

      expect(config.artifactsDir).toBe('my-custom-dir');
      expect(config.gitOps?.post_merge?.strategy).toBe('direct_commit');
      expect(config.gitOps?.post_merge?.direct_commit?.push_immediately).toBe(
        false
      );
    });
  });
}
```

**Usage:**
```typescript
// test/validate-config.contract.test.ts
import { contractConfigValidator } from './contracts/config-validator.contract.js';
import { validateConfig } from '../src/validate-config.js';

contractConfigValidator('ZodValidator', validateConfig);
```

---

## F) RISK MAP & HOTSPOT ANALYSIS

| Module | Churn (180 days) | Coverage | Mutation (est.) | Qual. Grade | Risk Score | Action |
|--------|------------------|----------|-----------------|-------------|------------|--------|
| **validate-config.ts** | üî• **617 LOC** | 100% | ‚ö†Ô∏è ~65% | A- | **MEDIUM** | Add mutation testing; consolidate enum tests; add property tests |
| **load-config.ts** | 105 LOC | 100% | ~75% | A- | LOW | Add contract tests; property tests for round-trip |
| **migrate-config.ts** | 167 LOC | 100% | ~80% | A | LOW | Add property tests for idempotence and version detection |
| **presets/** | ~450 LOC | 100% | ~90% | A+ | **VERY LOW** | Exemplary - low risk, stable and well-tested |
| **types.ts** | 14 LOC | N/A | N/A | N/A | NONE | Type definitions only |

**Legend:**
- üî• High churn = Most changed in last 180 days
- Risk Score = (Churn Percentile) √ó (1 - Estimated Mutation Score) √ó (1 - Qual. Grade / 100)

**Hottest Spot:** [src/validate-config.ts](src/validate-config.ts) - 617 additions, complex Zod schemas, many enum validations. **Mutation testing will reveal if validations actually catch errors.**

**Coldest Spot:** [src/presets/](src/presets/) - Stable, well-tested preset definitions. Exemplary test quality.

---

## G) STATIC ANALYSIS FINDINGS

### 1. Snapshot Burden
**Finding:** Zero snapshots. ‚úÖ **EXCELLENT** - No snapshot debt.

### 2. Mock Ratio
**Finding:** 0 mocks / 140 tests = **0% mock ratio**. ‚úÖ **OUTSTANDING**
- Zero `vi.mock()` calls
- Zero `vi.spyOn()` calls
- Tests use real implementations (appropriate for config validation)

### 3. Timer/RNG Usage
**Finding:** One use of `Date.now()` for temp directory names. ‚ö†Ô∏è

**Location:** [load-config.test.ts:39](src/load-config.test.ts#L39)
```typescript
testDir = join(tmpdir(), `kodebase-config-test-${Date.now()}`);
```

**Risk:** Non-deterministic test paths. Race conditions if tests run at same millisecond.

**Action:** Apply Section D.2 (fake timers in test/setup.ts).

### 4. Focused/Skipped Tests
**Finding:** Zero `.only` or `.skip` in codebase. ‚úÖ **CLEAN**

### 5. Assertion Quality
**Finding:** 350+ assertions total. Breakdown:
- Semantic (state checks): ~320 (91%) ‚úÖ
- Structural (`toBeDefined`, `toBeInstanceOf`): ~30 (9%) ‚ö†Ô∏è

**Examples of strong assertions:**
```typescript
expect(config.gitOps?.post_merge?.strategy).toBe("cascade_pr");
expect(config.gitOps?.validation?.error_on_warnings).toBe(true);
```

**Weaker patterns:**
```typescript
expect(result.config).toBeDefined(); // No semantic meaning
expect(result.warnings).toEqual([]); // Could be more specific
```

**Action:** Review 30 structural assertions; convert to semantic checks.

### 6. Arrange Bloat
**Finding:** Average arrange lines per test:
- **Integration tests:** 25 lines (20-30 line YAML strings) ‚ùå
- Unit tests (validation): 5 lines ‚úÖ
- Unit tests (migration): 8 lines ‚úÖ

**Worst offenders:**
- [integration.test.ts:48-89](src/integration.test.ts#L48-L89): 40-line YAML string
- [load-config.test.ts:146-182](src/load-config.test.ts#L146-L182): 35-line YAML string

**Action:** Extract `ConfigBuilder.toYAML()` (Section D.4); reduce to 3-5 lines.

### 7. Redundancy Detection
**Finding:** Manual scan found 2 patterns of redundancy:
1. **Enum validation** (5 near-duplicate tests in validate-config.test.ts:68-100)
2. **Error handling** (4 similar try-catch blocks in load-config.test.ts)

**Action:** Consolidate enum tests (Section C.2); extract error assertion helper (Section C.6).

---

## H) EXECUTION HEALTH

### Test Duration (from coverage run)
**Total:** 81ms (excellent for 140 tests across 5 files)

**Breakdown:**
1. [load-config.test.ts](src/load-config.test.ts): 32ms (real file I/O)
2. [integration.test.ts](src/integration.test.ts): 32ms (real file I/O)
3. [validate-config.test.ts](src/validate-config.test.ts): 7ms (pure validation)
4. [presets.test.ts](src/presets/presets.test.ts): 6ms (pure validation)
5. [migrate-config.test.ts](src/migrate-config.test.ts): 5ms (pure logic)

**Analysis:**
- 79% of time (64ms / 81ms) in file I/O tests ‚úÖ **Appropriate** - Config package needs real file testing
- No individual test >500ms ‚úÖ
- No slow outliers ‚úÖ

**Health:** ‚úÖ **EXCELLENT** - Fast, balanced execution.

### Flake Rate
**Finding:** No CI logs provided. **Assumed: 0% flake rate** based on:
- Proper temp directory isolation
- No network calls
- No timing dependencies (except `Date.now()` which is low risk)

**Risk:** `Date.now()` in temp directory names could cause rare collision if parallel tests execute at exact same millisecond.

**Action:** Add fake timers (Section D.2) to eliminate this risk.

### Skew Analysis
**Finding:** File I/O tests account for 79% of time, but this is appropriate for integration testing.
- No single test >40ms
- Well-balanced distribution

**Health:** ‚úÖ **GOOD** - No problematic skew.

---

## I) TOOLING HYGIENE

### Current State: ‚ö†Ô∏è **MODERATE**

1. **Vitest Config:** ‚úÖ Clean, has coverage thresholds (90/90/80/90)
2. **Coverage Provider:** ‚úÖ Istanbul (good choice)
3. **No Stryker Config:** ‚ùå **CRITICAL GAP**
4. **No ESLint test rules:** ‚ùå Missing (see Section D.1)
5. **No test/setup.ts:** ‚ùå Missing (see Section D.2)
6. **CI Coverage Gates:** ‚úÖ (thresholds in vitest.config)

### Missing CI Checks

**Recommended additions to `.github/workflows/test.yml` (or equivalent):**

```yaml
# packages/config CI checks
- name: Run unit tests (config)
  run: pnpm --filter @kodebase/config test

- name: Check coverage thresholds
  run: pnpm --filter @kodebase/config test:coverage

- name: Run mutation tests (config)
  if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
  run: cd packages/config && npx stryker run --incremental

- name: Check for focused tests (config)
  run: |
    if grep -r "\.only\|\.skip" packages/config/src/**/*.test.ts; then
      echo "Error: Focused or skipped tests found in @kodebase/config"
      exit 1
    fi

- name: Check mutation score threshold
  if: github.event_name == 'pull_request'
  run: |
    cd packages/config
    SCORE=$(jq '.mutation.score' reports/mutation/mutation.json)
    if (( $(echo "$SCORE < 70" | bc -l) )); then
      echo "Mutation score $SCORE is below threshold 70%"
      exit 1
    fi
```

---

## J) SUMMARY & FINAL RECOMMENDATIONS

### What's Working Well

1. **Perfect coverage (100%)** - All lines, branches, functions covered. No gaps.
2. **Zero mocks** - Tests use real implementations, testing actual behavior.
3. **Excellent preset testing** - Comparative tests ("strictness increases") encode business rules.
4. **Clean test structure** - Consistent AAA pattern, descriptive names, good nesting.
5. **No snapshot debt** - Zero snapshots is a massive win.
6. **Fast execution** - 81ms for 140 tests is outstanding.

### Critical Weaknesses

1. **No mutation testing** - Cannot assess assertion strength. High risk of shallow assertions passing.
2. **Missing property tests** - Pure functions lack invariant testing (idempotence, monotonicity, round-trips).
3. **Non-deterministic time** - `Date.now()` in test setup creates potential race conditions.
4. **Arrange bloat** - Integration tests have 20-30 line YAML setup blocks.
5. **Test redundancy** - Enum validation pattern repeated 5 times; consolidate with parameterized tests.

### Priority Actions (Next 7 Days)

1. **Install Stryker** - Run baseline mutation report (Section D.3) [Priority: CRITICAL]
2. **Add test/setup.ts** - Fake timers for `Date.now()` (Section D.2) [Priority: HIGH]
3. **Create ConfigBuilder** - Reduce arrange bloat from 25 lines to 3-5 (Section D.4) [Priority: MEDIUM]
4. **Add 5 property tests** - Idempotence, round-trip, version detection (Section C.4, C.5, C.10) [Priority: MEDIUM]
5. **Consolidate enum tests** - Reduce from 32 lines to 15 (Section C.2) [Priority: LOW]

### Long-Term Vision (90 Days)

**Goal:** Mutation score 85%+, 15+ property tests, <10 line average test, <5% arrange bloat.

**Culture Shift:** "Test invariants with properties. Build test data with builders. Validate assertions with mutation testing."

---

## APPENDIX: Key File References

**Exemplary Tests (Study These):**
- [presets.test.ts](src/presets/presets.test.ts) - Outstanding: comparative tests, business rule encoding, zero mocks
- [migrate-config.test.ts](src/migrate-config.test.ts) - Strong: idempotence tests, edge case coverage, future-proofing

**Tests Needing Attention:**
- [validate-config.test.ts](src/validate-config.test.ts) - Consolidate enum tests (lines 68-100)
- [integration.test.ts](src/integration.test.ts) - Extract ConfigBuilder for YAML setup
- [load-config.test.ts](src/load-config.test.ts) - Add fake timers for deterministic temp directories

**Coverage Data:**
- [coverage/lcov.info](coverage/lcov.info) - 72 lines covered, 100% coverage
- [coverage/index.html](coverage/index.html) - Visual coverage report

**Mutation (TODO):**
- `stryker.conf.cjs` - Not yet created (Section D.3)
- Target: 85% mutation score

---

**End of Report**
